package com.cjr.qita;

/**
 * 给定一个整数 n ，返回 n! 结果中尾随零的数量。
 * 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
 * 示例 1：
 * 输入：n = 3
 * 输出：0
 * 解释：3! = 6 ，不含尾随 0
 * 示例 2：
 * 输入：n = 5
 * 输出：1
 * 解释：5! = 120 ，有一个尾随 0
 * 示例 3：
 * 输入：n = 0
 * 输出：0
 * 提示：
 * 0 <= n <= 104
 */

/**
 * 0的贡献来源于：本身有0，或是偶数与5的倍数相乘获得；
 * 1、由于偶数的个数一定比5的倍数的个数多，因而对于这种情况只考虑5的倍数的个数
 * 2、本身有0的数恰好是5的倍数，拥有的0的个数恰好又与是5^n的倍数的n相等
 * 综上，只需要计算阶乘中各个5的次方数的个数和即可。【因为是多少次方就会在其中被计算多少次，因而不需要考虑是否会有重复计算的问题】
 */
public class 阶乘后的零 {
    public int trailingZeroes(int n) {
        int count = 0;
        while(n >= 5){
            n = n / 5;
            count += n;
        }
        return count;
    }
}
