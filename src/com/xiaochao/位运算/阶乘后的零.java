package com.xiaochao.位运算;

/**
 * ⾸先，两个数相乘结果末尾有 0，⼀定是因为两个数中有因⼦ 2 和 5，也就是说，问题转化为：n! 最多可以 分解出多少个因⼦ 2 和 5？
 * 最多可以分解出多少个因⼦ 2 和 5，主要取决于能分解出⼏个因⼦ 5，因为每个偶数都能分解出因⼦ 2，因⼦ 2 肯定⽐因⼦ 5 多得多。
 * 那么，问题转化为：n! 最多可以分解出多少个因⼦ 5？难点在于像 25，50，125 这样的数，可以提供不⽌ ⼀个因⼦ 5，不能漏数了。
 * 这样，我们假设 n = 125，来算⼀算 125! 的结果末尾有⼏个 0： ⾸先，125 / 5 = 25，这⼀步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们⼀定可以提供⼀个因 ⼦ 5。
 * 但是，这些⾜够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因⼦ 5，那么我们再计算出
 * 125! 中有 125 / 25 = 5 个 25 的倍数，它们每⼈可以额外再提供⼀个因⼦ 5。 够了吗？我们发现 125 = 5 x 5 x 5，
 * 像 125，250 这些 125 的倍数，可以提供 3 个因⼦ 5，那么我们还得再计 算出 125! 中有 125 / 125 = 1 个 125 的倍数，
 * 它还可以额外再提供⼀个因⼦ 5。 这下应该够了，125! 最多可以分解出 25 + 5 + 1 = 31 个因⼦ 5，也就是说阶乘结果的末尾有 31 个 0
 */
public class 阶乘后的零 {
    public int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) {
            res += n / divisor;
            divisor *= 5;
        }
        return res;
    }
}
