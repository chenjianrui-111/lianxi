package com.xiaochao.位运算;

/**
 * 桌⼦上有⼀堆⽯头，你们轮流进⾏⾃⼰的回合，你作为先⼿；每⼀回合，轮到的⼈拿掉 1 ~ 3 块⽯头，拿掉 最后⼀块⽯头的⼈就是获胜者。
 * 假设你们每⼀步都是最优解，请编写⼀个函数，来判断你是否可以在给定⽯头数量为 n 的情况下赢得游戏。 如果可以赢，返回 true；
 * 否则，返回 false。 示例 1：输⼊：n = 4
 * 输出：false
 * 解释：如果堆中有 4 块⽯头，那么你永远不会赢得⽐赛；
 *  因为⽆论你拿⾛ 1 块、2 块 还是 3 块⽯头，最后⼀块⽯头总是会被你的朋友拿⾛。
 *  解法
 *  我们解决这种问题的思路⼀般都是反着思考： 如果我能赢，那么最后轮到我取⽯⼦的时候必须要剩下 1~3 颗⽯⼦，这样我才能⼀把拿完。
 *  如何营造这样的⼀个局⾯呢？显然，如果对⼿拿的时候只剩 4 颗⽯⼦，那么⽆论他怎么拿，总会剩下 1~3 颗 ⽯⼦，我就能赢。
 *  如何逼迫对⼿⾯对 4 颗⽯⼦呢？要想办法，让我选择的时候还有 5~7 颗⽯⼦，这样的话我就有把握让对⽅不 得不⾯对 4 颗⽯⼦。
 *  如何营造 5~7 颗⽯⼦的局⾯呢？让对⼿⾯对 8 颗⽯⼦，⽆论他怎么拿，都会给我剩下 5~7 颗，我就能赢。 这样⼀直循环下去，
 *  我们发现只要踩到 4 的倍数，就落⼊了圈套，永远逃不出 4 的倍数，⽽且⼀定会输
 */
public class Nim游戏 {
    public boolean canWinNim(int n) {
        // 如果上来就踩到 4 的倍数，那就认输吧
        // 否则，可以把对⽅控制在 4 的倍数，必胜
        return n % 4 != 0;
    }
}
