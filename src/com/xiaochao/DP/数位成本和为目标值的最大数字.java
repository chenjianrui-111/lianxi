package com.xiaochao.DP;

import java.util.Arrays;

/**
 * 给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：
 * 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。
 * 总成本必须恰好等于 target 。
 * 添加的数位中没有数字 0 。
 * 由于答案可能会很大，请你以字符串形式返回。
 * 如果按照上述要求无法得到任何整数，请你返回 "0" 。
 * 示例 1：
 * 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
 * 输出："7772"
 * 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
 *  数字     成本
 *   1  ->   4
 *   2  ->   3
 *   3  ->   2
 *   4  ->   5
 *   5  ->   6
 *   6  ->   7
 *   7  ->   2
 *   8  ->   5
 *   9  ->   5
 * 示例 2：
 * 输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
 * 输出："85"
 * 解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
 * 示例 3：
 * 输入：cost = [2,4,6,2,4,6,4,4,4], target = 5
 * 输出："0"
 * 解释：总成本是 target 的条件下，无法生成任何整数。
 * 示例 4：
 * 输入：cost = [6,10,15,40,40,40,40,40,40], target = 47
 * 输出："32211"
 * 提示：
 * cost.length == 9
 * 1 <= cost[i] <= 5000
 * 1 <= target <= 5000
 */
public class 数位成本和为目标值的最大数字 {
    public String largestNumber(int[] cost, int target) {
        int[] f= new int[target + 1];
        Arrays.fill(f,Integer.MIN_VALUE);
        f[0] = 0;
        for (int i = 1; i <= 9 ; i++) {
            int u = cost[i - 1];
            for (int j = u;j <= target; j++){
                f[j] = Math.max(f[j],f[j - u] + 1);
            }
        }
        if (f[target] < 0) return "0";
        String ans = "";
        for (int i = 9, j = target; i >= 1; i--) {
            int u = cost[i - 1];
            while (j >= u && f[j] == f[j - u] + 1) {
                ans += String.valueOf(i); j -= u; } }
        return ans;
    }
}
//• 时间复杂度：O(n ∗ t) • 空间复杂度：O(t)
/**
 *思考 & 进阶
 * 懂得分两步考虑的话，这道题还是挺简单。虽然是「DP」+「贪心」，但两部分都不难。
 * 其实这道题改改条件/思路，也能衍生出几个版本：
 * 0. 【思考】如何彻底转化为「01 背包」或者「多重背包」来处理？
 * 完全背包经过一维优化后时间复杂度为 O(N ∗ C)。是否可以在不超过此复杂度的
 * 前提下，通过预处理物品将问题转换为另外两种传统背包？
 * ◦ 对于「多重背包」答案是可以的。由于给定的最终费用 t，我们可以明
 * 确算出每个物品最多被选择的次数，可以在 O(N) 的复杂度内预处理
 * 额外的 s[] 数组。然后配合「单调队列优化」，做到 O(N ∗ C) 复杂度，整体复杂度不会因此变得更差。
 * 但转换增加了「预处理」的计算量。为了让转换变成“更有意义”，我们
 * 可以在「预处理」时顺便做一个小优化：对于相同成本的数字，只保留
 * 数值大的数字。不难证明，当成本相同时，选择更大的数字不会让结果变差。
 * ◦ 对于「01 背包」答案是不可以。原因与「多重背包」单纯转换为「01
 * 背包」不会降低复杂度一致。因此本题转换成「01 背包」会使得 N 发非常数级别的增大。
 * 1. 【进阶】不再是给定数值 1~9（取消 cost 数组），转为给定 nums 数组（代表所
 * 能选择的数字，不包含 0），和相应 price 数组（长度与 nums 一致，代表选择 nums[i] 所消耗的成本为 price[i]）。现有做法是否会失效？
 * 此时 nums 中不再是只有长度为 1 的数值了。但我们「判断数值大小」的两条规 则不变。因此「第一步」不需要做出调整，但在进行「第二步」开始前，我们要先
 * 对物品进行「自定义规则」的排序，确保「贪心」构造答案过程是正确的。规则与 证明都不难请自行思考。
 * 2. 【进阶】在进阶 1 的前提下，允许 nums 出现 0，且确保答案有解（不会返回答案0）,该如何求解？
 * 增加数值 0 其实只会对最高位数字的决策产生影响。
 * 我们可以通过预处理转换为「分组 & 树形」背包问题：将 nums 中的非 0 作为一 组「主件」（分组背包部分：必须选择一个主件），所有数值作为「附属件」（树
 * 形背包部分：能选择若干个，选择附属件必须同时选择主件）。
 */
