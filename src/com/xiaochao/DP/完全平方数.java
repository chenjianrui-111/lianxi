package com.xiaochao.DP;

/**
 * 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量
 * 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
 * 示例 1：
 * 输入：n = 12
 * 输出：3
 * 解释：12 = 4 + 4 + 4
 * 示例 2：
 * 输入：n = 13
 * 输出：2
 * 解释：13 = 4 + 9
 * 提示：
 * 1 <= n <= 104
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 完全背包（朴素解法）
 * 首先「完全平方数」有无限个，但要凑成的数字是给定的。
 * 因此第一步可以将范围在 [1, n] 内的「完全平方数」预处理出来。
 * 这一步其实就是把所有可能用到的「物品」预处理出来。
 * 从而将问题转换为：给定了若干个数字，每个数字可以被使用无限次，求凑出目标值 n 所需要
 * 用到的是最少数字个数是多少。
 * 由于题目没有限制我们相同的「完全平方数」只能使用一次，属于「完全背包」模型。
 * 目前我们学过的两类背包问题（01 背包 & 完全背包）的原始状态定义都是两维： • 第一维 i 代表物品编号 • 第二维 j 代表容量
 * 其中第二维 j 又有「不超过容量 j」和「容量恰好为 j」两种定义，本题要我们求「恰好」凑出
 * n 所需要的最少个数。
 * 因此我们可以调整我们的「状态定义」：
 * f[i][j] 为考虑前 i 个数字，凑出数字总和 j 所需要用到的最少数字数量。
 * 不失一般性的分析 f[i][j]，对于第 i 个数字（假设数值为 t），我们有如下选择： • 选 0 个数字 i，此时有 f[i][j] = f[i − 1][j] • 选 1 个数字 i，
 * 此时有 f[i][j] = f[i − 1][j − t] + 1 • 选 2 个数字 i，此时有 f[i][j] = f[i − 1][j − 2 ∗ t] + 2 …• 选 k 个数字 i，此时有 f[i][j] = f[i − 1][j − k ∗ t] + k
 * 因此我们的状态转移方程为： f[i][j] = min(f[i − 1][j − k ∗ t] + k), 0 ⩽ k ∗ t ⩽ j
 * 当然，能够选择 k 个数字 i 的前提是，剩余的数字 j − k ∗ t 也能够被其他「完全平方数」凑
 * 出，即 f[i − 1][j − k ∗ t] 为有意义的值。
 * 代码（朴素完全背包问题的复杂度是 O(n2 ∗ n) 的，有超时风险，让物品下标从 0 开始，单
 * 独处理第一个物品的 P2 代码勉强能过）：
 */
public class 完全平方数 {
    int INF = 0x3f3f3f3f;
    public int numSquares(int n) {
        //预处理出所有可能用到的完全平方数
        List<Integer> list = new ArrayList<>();
        int t = 1;
        while (t * t <= n){
            list.add(t * t);
            t++;
        }
        //f[i][j] 代表考虑前 i 个物品，凑出 j 所使用的最小元素个数
        int m  = list.size();
        int[][] f = new int[m + 1][n + 1];
        //当没有任何数时，除了 f[0][0] 为 0
        Arrays.fill(f[0],INF);
        f[0][0] = 0;

        // 处理剩余数的情况
        for (int i = 1; i <= m ; i++) {
            int x = list.get(i - 1);
            for (int j = 0; j <= n ; j++) {
                //对于不选择第 i 个数的情况
                f[i][j] = f[i - 1][j];
                // 对于选 k 次第 i 个数的情况
                for (int k = 1; k * x <= j; k++) {
                    // 能够选择 k 个 x 的前提是剩余的数字 j - k * x 也能被凑出
                   if (f[i - 1][j - k * x] != INF){
                       f[i][j] = Math.min(f[i][j],f[i - 1][j - k * x] + k);
                   }
                }
            }
        }
        return f[m][n];
    }
}

class Solution {
    public int numSquares(int n) {
        int[] f = new int[n + 1];
        Arrays.fill(f, 0x3f3f3f3f);
        f[0] = 0;
        for (int t = 1; t * t <= n; t++) {
            int x = t * t;
            for (int j = x; j <= n; j++) {
                f[j] = Math.min(f[j], f[j - x] + 1);
            }
        }
        return f[n];
    }
}
//• 时间复杂度：共有 n ∗ n 个状态需要转移，复杂度为 O(n ∗ n)。 • 空间复杂度：O(n)。
