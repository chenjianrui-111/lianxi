package com.xiaochao.DP.区间DP;

/**
 * 给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。
 * 通过从 s 中删除  0个或多个字符来获得子序列。
 * 如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。
 * 如果有某个 i , 满足 ai != bi ，则两个序列 a1, a2, ... 和 b1, b2, ... 不同。
 * 注意：
 * 结果可能很大，你需要对 10^9+7 取模 。
 * 示例 1：
 * 输入：s = 'bccb'
 * 输出：6
 * 解释：6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
 * 注意：'bcb' 虽然出现两次但仅计数一次。
 * 提示：
 * 1 <=s.length <=1000
 */

import java.util.Arrays;

/**
 * 区间 DP
 * 往长度较少的回文串两端添加字符，可能组成新的长度大的回文串，容易想到「区间 DP」，同时 s 仅由 4 类小写字母组成，也是一个切入点。
 * 根据区间 DP 的一般思路，定义 f[i][j] 为考虑字符串 s 中的 [i,j] 范围内回文子序列的个数，最终答案为 f[0][n-1]。
 * 不失一般性考虑 f[i][j] 该如何转移，通过枚举 abcd 作为回文方案「边缘字符」来进行统计，即分别统计各类字符作为「边缘字符」时对 f[i][j] 的贡献，此类统计方式天生不存在重复性问题。
 * 假设当前枚举到的字符为 k ：
 * 若 s[i..j] 中没有字符 k，则字符 k 对 f[i][j] 贡献为  0 ，跳过；
 * 若 s[i..j] 中存在字符 k，根据字符k  在范围 s[i..j] 中「最小下标」和「最大下标」进行分情况讨论，假设字符 k 在 s[i..j] 中「最靠左」的位置为 l，「最靠右」的位置为 r：
 * 当 l=r 时，此时字符 k 对 f[i][j] 的贡献为 1 ，即 k 本身；
 * 当 l = r-1 时，说明字符 k 中间不存在任何字符，此时字符 k 对 f[i][j] 的贡献为 2 ，包括 k 和 kk 两种回文方案；
 * 其余情况，可根据已算得的「小区间回文方案」进行延伸（两段分别补充位于 l  和 r 的字符 k ），得到新的大区间方案，此部分对f[i][j]  的贡献是 f[l+1][r-1] ，
 * 另外还有 k 和 kk 两种回文方案，因此总的对答案的贡献为 f[l+1][r-1] + 2 。
 * 统计 s[i..j] 中各类字符「最靠左」和「最靠右」的位置，可通过调整枚举方向来实现：从大到小枚举 ，同时维护 L[s[i]-'a'] = i，
 * 即可得到「最靠左」的位置；在确定左端点 i 之后，从小到大枚举右端点 j，同时维护 R[s[j]-'a'] = j，即可得到「最靠右」的位置。
 */
public class 统计不同回文子序列 {
    int MOD = (int)1e9+7;
    public int countPalindromicSubsequences(String s) {
        char[] cs = s.toCharArray();
        int n = cs.length;
        int[][] f = new int[n][n];
        int[] L = new int[4], R = new int[4];
        Arrays.fill(L, -1);
        for (int i = n - 1; i >= 0; i--) {
            L[cs[i] - 'a'] = i;
            Arrays.fill(R, -1);
            for (int j = i; j < n; j++) {
                R[cs[j] - 'a'] = j;
                for (int k = 0; k < 4; k++) {
                    if (L[k] == -1 || R[k] == -1) continue;
                    int l = L[k], r = R[k];
                    if (l == r) f[i][j] = (f[i][j] + 1) % MOD;
                    else if (l == r - 1) f[i][j] = (f[i][j] + 2) % MOD;
                    else f[i][j] = (f[i][j] + f[l + 1][r - 1] + 2) % MOD;
                }
            }
        }
        return f[0][n - 1];
    }
}
//时间复杂度：O(C*N2)，其中C = 4  为字符集大小
//空间复杂度：O(N2)
