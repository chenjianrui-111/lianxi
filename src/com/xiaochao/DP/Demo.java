package com.xiaochao.DP;

/**
 * 一个二维数组，其中一维代表当前「当前枚举到哪件物品」，另外一维「现在的剩余容量」，数组装的是「最大价值」。
 * 根据 dp 数组不难得出状态定义：
 * 考虑前 i 件物品，使用容量不超过 C 的条件下的背包最大价值。
 * 当有了状态定义之后，我们再根据「最后一步」选择来推导「状态转移方程」。
 * 不失一般性的，我们只需要考虑第 i 件物品如何选择即可，对于第 i 件物品，我们有「选」和「不选」两种决策。
 * 结合我们的「状态定义」，「不选」方案的「最大价值」很好确定：
 * 「不选」其实就是  dp[i - 1][c] ，等效于我们只考虑前 i - 1 件物品，当前容量为 C 的情况下的最大价值。
 * 同理，如果我们选第 i 件物品的话，代表消耗了 v[i] 的背包容量，获取了 w[i] 的价值，那么留给前 i - 1 件物品的背包容量就只剩 C -v[i] 。即最大价值为 dp[i-1][c-v[i]] + w[i] 。
 * 当然，选第  件有一个前提：「当前剩余的背包容量」「物品的体积」。
 * 在「选」和「不选」之间取最大值，就是我们「考虑前 i 件物品，使用容量不超过 C 」的条件下的「背包最大价值」。
 * 即可得「状态转移方程」为：
 * dp[i][c] = max(dp[i - 1][c],dp[i - 1][c -v[i]] + w[i])
 */
public class Demo {
    public int maxValue(int N, int C, int[] v, int[] w) {
        int[][] dp = new int[N][C+1];
        // 先处理「考虑第一件物品」的情况
        for (int i = 0; i <= C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        // 再处理「考虑其余物品」的情况
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < C + 1; j++) {
                // 不选该物品
                int n = dp[i-1][j];
                // 选择该物品，前提「剩余容量」大于等于「物品体积」
                int y = j >= v[i] ? dp[i-1][j-v[i]] + w[i] : 0;
                dp[i][j] = Math.max(n, y);
            }
        }
        return dp[N-1][C];
    }
}
//时间复杂度：共有 N*C 个状态需要被转移，复杂度为 O(N*C)
//空间复杂度：O(N*C)
/**
 *
 dp[2][C+1] 解法
 根据「转移方程」，我们知道计算第 i  行格子只需要第 i - 1 行中的某些值。
 也就是计算「某一行」的时候只需要依赖「前一行」。
 因此可以用一个只有两行的数组来存储中间结果，根据当前计算的行号是偶数还是奇数来交替使用第 0 行和第 1 行。
 这样的空间优化方法称为「滚动数组」，我在 路径问题 第四讲 也曾与你分享过。
 这种空间优化方法十分推荐，因为改动起来没有任何思维难度。
 只需要将代表行的维度修改成 2，并将所有使用行维度的地方从 i 改成 i%2 或者 i&1 即可（更建议使用 i&1 ，& 运算在不同 CPU 架构的机器上要比 % 运算稳定）。
 */
class Solution4 {
    public int maxValue(int N, int C, int[] v, int[] w) {
        int[][] dp = new int[2][C+1];
        // 先处理「考虑第一件物品」的情况
        for (int i = 0; i < C + 1; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        // 再处理「考虑其余物品」的情况
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < C + 1; j++) {
                // 不选该物品
                int n = dp[(i-1)&1][j];
                // 选择该物品
                int y = j >= v[i] ? dp[(i-1)&1][j-v[i]] + w[i] : 0;
                dp[i&1][j] = Math.max(n, y);
            }
        }
        return dp[(N-1)&1][C];
    }
}
//时间复杂度：共有 N*C 个状态需要被转移，复杂度为 O(N*C)
//空间复杂度：O(C)
/**
 * dp[C+1] 解法
 * 事实上，我们还能继续进行空间优化，只保留代表「剩余容量」的维度。
 * 再次观察我们的「转移方程」：
 * dp[i][c] = max(dp[i - 1][c],dp[i - 1][c- v[i]] + w[i])
 * 不难发现当求解第 i 行格子的值时，不仅是只依赖第 i-1 行，还明确只依赖第 i-1 行的第 c 个格子和第 c-v[i] 个格子（也就是对应着第 i 个物品不选和选的两种情况）。
 * 换句话说，只依赖于「上一个格子的位置」以及「上一个格子的左边位置」。
 */
class Solution5 {
    public int maxValue(int N, int C, int[] v, int[] w) {
        int[] dp = new int[C + 1];
        for (int i = 0; i < N; i++) {
            for (int j = C; j >= v[i]; j--) {
                // 不选该物品
                int n = dp[j];
                // 选择该物品
                int y = dp[j-v[i]] + w[i];
                dp[j] = Math.max(n, y);
            }
        }
        return dp[C];
    }
}
//时间复杂度：共有 N*C 个状态需要被转移，复杂度为 O(N*C)
//空间复杂度：O(C)
