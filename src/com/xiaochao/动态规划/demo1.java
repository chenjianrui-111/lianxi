package com.xiaochao.动态规划;

/**
 * 一、两种思路
 * 1、第一种思路模板是一个一维的 dp 数组：
 * int n = array.length;
 * int[] dp = new int[n];
 * for (int i = 1; i < n; i++) {
 *     for (int j = 0; j < i; j++) {
 *         dp[i] = 最值(dp[i], dp[j] + ...)
 *     }
 * }
 * 比如我们写过的 最长递增子序列 和 最大子数组和 都是这个思路。
 * 在这个思路中 dp 数组的定义是：
 * 在子数组 arr[0..i] 中，我们要求的子序列（最长递增子序列）的长度是 dp[i]。
 * 为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。
 * 2、第二种思路模板是一个二维的 dp 数组：
 * Copy
 * int n = arr.length;
 * int[][] dp = new dp[n][n];
 * for (int i = 0; i < n; i++) {
 *     for (int j = 0; j < n; j++) {
 *         if (arr[i] == arr[j])
 *             dp[i][j] = dp[i][j] + ...
 *         else
 *             dp[i][j] = 最值(...)
 *     }
 * }
 * 这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列时，比如前文讲的 最长公共子序列 和 编辑距离；这种思路也可以用于只涉及一个字符串/数组的情景，比如本文讲的回文子序列问题。
 * 2.1 涉及两个字符串/数组的场景，dp 数组的定义如下：
 * 在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，我们要求的子序列长度为 dp[i][j]。
 * 2.2 只涉及一个字符串/数组的场景，dp 数组的定义如下：
 * 在子数组 array[i..j] 中，我们要求的子序列的长度为 dp[i][j]。
 */
public class demo1 {

}
