package com.xiaochao.树.差分;
/**
 * 这里有 n 个航班，它们分别从 1 到 n 进行编号。
 * 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着
 * 在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
 * 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
 * 示例 1：
 * 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
 * 输出：[10,55,45,25,25]
 * 解释：
 * 航班编号        1   2   3   4   5
 * 预订记录 1 ：   10  10
 * 预订记录 2 ：       20  20
 * 预订记录 3 ：       25  25  25  25
 * 总座位数：      10  55  45  25  25
 * 因此，answer = [10,55,45,25,25]
 */
/**
 * 区间和 解决方案：
 * 针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：
 * 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
 * 多次修改某个数（单点），求区间和：「树状数组」、「线段树」
 * 多次修改某个区间，输出最终结果：「差分」
 * 多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）
 * 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）
 * 这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？
 * 答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。
 * 因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。
 * 总结一下，我们应该按这样的优先级进行考虑：
 * 1.简单求区间和，用「前缀和」
 * 2.多次将某个区间变成同一个数，用「线段树」
 * 3.其他情况，用「树状数组」
 */
//• 数组不变，区间查询：前缀和、树状数组、线段树；
// • 数组单点修改，区间查询：树状数组、线段树；
// • 数组区间修改，单点查询：差分、线段树；
// • 数组区间修改，区间查询：线段树。

/**
 * 差分
 * 本题只涉及「区间修改 + 单点查询」，因此是一道「差分」的模板题。
 * 「差分」可以看做是求「前缀和」的逆向过程。
 * 对于一个「将区间 [l, r] 整体增加一个值 v」操作，我们可以对差分数组 c 的影响看成两部分：
 * • 对 c[l]+ = v：由于差分是前缀和的逆向过程，这个操作对于将来的查询而言，带 来的影响是对于所有的下标大于等于 l 的位置都增加了值 v；
 * • 对 c[r + 1]− = v：由于我们期望只对 [l, r] 产生影响，因此需要对下标大于 r 的
 * 位置进行减值操作，从而抵消“影响”。
 * 对于最后的构造答案，可看做是对每个下标做“单点查询”操作，只需要对差分数组求前缀和即
 * 可。
 */
public class 航班预定统计 {
    public int[] corpFlightBookings(int[][] bs, int n) {
        int[] c = new int[n+1];
        for (int[] bo : bs) {
            int l = bo[0] - 1,r= bo[1] - 1,v =bo[2];
            c[l] += v;
            c[r+1] -= v;
        }
        int[] ans =new int[n];
        ans[0] = c[0];
        for (int i = 1; i < n ; i++) {
            ans[i] = ans[i - 1] + c[i];
        }
        return ans;
    }
}
//• 时间复杂度：令 bs 长度为 m，预处理差分数组的复杂度为 O(m)；构造答案复
//杂度为 O(n)。整体复杂度为 O(m + n) • 空间复杂度：O(n)
