package com.daimasuixianglu.beibao.duoweibeibao;

/**
 * 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
 * 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。
 * 如果成员参与了其中一项工作，就不能参与另一项工作。
 * 工作的任何至少产生 minProfit 利润的子集称为「盈利计划」。并且工作的成员总数最多为 n。
 * 有多少种计划可以选择？
 * 因为答案很大，所以 返回结果模 10^9+7 的值。
 * 输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
 * 输出：2
 * 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
 * 总的来说，有两种计划。
 * 思路
 * 定义 f[i][j][k] 为考虑前 i 件物品，使用人数不超过 j，所得利润至少为 k 的方案数。
 * 对于每件物品（令下标从 1 开始），我们有「选」和「不选」两种决策：
 * 不选：显然有：f[i-1][j][k]
 * 选：首先需要满足人数达到要求（ j>=group[i-1] ），还需要考虑「至少利润」负值问题：如果直接令「利润维度」为 k-profit[i-1] 可能会出现负值，那么负值是否为合法状态呢？这需要结合「状态定义」来看，由于是「利润至少为 k」，因此属于「合法状态」，需要参与转移。
 * 由于我们没有设计动规数组存储「利润至少为负权」状态，我们需要根据「状态定义」做一个等价替换，将这个「状态」映射到 。这主要是利用所有的任务利润都为“非负数”，所以不可能出现利润为负的情况，这时候「利润至少为某个负数 」的方案数其实是完全等价于「利润至少为 0」的方案数。
 * f[i-1][j-group[i-1]][max(k-profit[i-1],0)]
 * 最终 f[i][j][k] 为上述两种情况之和。
 * 然后考虑「如何构造有效起始值」问题，还是结合我们的「状态定义」来考虑：
 * 当不存在任何物品（任务）时，所得利用利润必然为 0（满足至少为0 ），同时对人数限制没有要求。
 * 因此可以让所有 f[0][x][0]=1。
 */
public class 盈利计划 {
    int mod= (int) (1e9+7);
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int m=group.length;
        // f[i][j][k] 代表考虑前 i 个任务，使用人数不超过 j，产生利益至少 k 的方案数
        int[][][] f=new int[m+1][n+1][minProfit+1];
        // 初始化：当没有任务时，无论有多少人，只有利益至少为 0 时的方案数为 1，其他为 0
        for (int j = 0; j <=n ; j++) {
            f[0][j][0]=1;
        }
        for (int i = 1; i <=m ; i++) {
            int g=group[i-1],p=profit[i-1];
            for (int j = 0; j <=n ; j++) {
                for (int k = 0; k <=minProfit ; k++) {
                    f[i][j][k]=f[i-1][j][k];
                    if (j>=g){
                        f[i][j][k]+=f[i-1][j-g][Math.max(0,k-p)];
                        f[i][j][k] %=mod;
                    }
                }
            }
        }
        return f[m][n][minProfit];
    }

}
