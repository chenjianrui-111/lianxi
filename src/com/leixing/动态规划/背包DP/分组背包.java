package com.leixing.动态规划.背包DP;

/**
 * 给定 N个物品组，和容量为 C 的背包。
 * 第 i个物品组共有 S[i] 件物品，其中第 i 组的第 j 件物品的成本为v[i][j] ，价值为w[i][j] 。
 * 每组有若干个物品，同一组内的物品最多只能选一个。
 * 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
 * 示例：
 * 输入：N = 2, C = 9, S = [2, 3], v = [[1,2,-1],[1,2,3]], w = [[2,4,-1],[1,3,6]]
 * 输出：10
 * 提示：
 * 0 < N,C,S[i] <100
 * 从题面看，这似乎是一种全新的背包问题。
 * 但其仍然是一种通过「枚举物品 - 枚举容量 - 枚举决策」来解决的组合优化问题。
 * 经过之前 三种传统背包问题 的学习。
 * 我们可以很轻松给出状态定义：定义 f[i][j] 为考虑前 i 个物品组，背包容量不超过 j 的最大价值。
 * 不失一般性的考虑 f[i][j] 如何计算。
 * 由于每组有若干个物品，且每组「最多」选择一件物品。
 */
public class 分组背包 {
    public int maxValue(int N, int C, int[] S, int[][] v, int[][] w) {
        int[][] dp = new int[N + 1][C + 1];
        for (int i = 1; i <= N; i++) {
            int[] vi = v[i - 1];
            int[] wi = w[i - 1];
            int si = S[i - 1];
            for (int j = 1; j <= C; j++) {
                dp[i][j] = dp[i - 1][j];
                for (int k = 0; k < si; k++) {
                    if (j >= vi[k]) {
                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - vi[k]] + wi[k]);
                    }
                }
            }
        }
        return dp[N][C];
    }
}
