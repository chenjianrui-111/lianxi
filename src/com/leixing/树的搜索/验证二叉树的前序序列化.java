package com.leixing.树的搜索;

/**
 * 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。
 * 如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
 *
 * 我们令非空节点数量为 m，空节点数量为 n，入度和出度仍然使用 in 和 out 代表。
 * 找一下 in 和 out 与 n 和 m 之间的关系。
 * 一颗合格二叉树 m 和 n 的最小的比例关系是 1 : 2，也就是对应了这么一个形状：
 * 而遍历过程中 m 和 n 的最小的比例关系则是 1 : 0，这其实对应了二叉树空节点总是跟在非空节点的后面这一性质。
 * 换句话说，在没到最后一个节点之前，我们是不会遇到 空节点数量 > 非空节点数量 的情况的。
 * 非空节点数量 >= 空节点数量 在遍历没结束前恒成立：m>=nm>=n
 * 之后我们再采用一个技巧，就是遍历过程中每遇到一个「非空节点」就增加两个「出度」和一个「入度」，每遇到一个「空节点」只增加一个「入度」。而不管每个「非空节点」是否真实对应两个子节点。
 * 那么我们的起始条件变成：
 * m >= n
 * in = m + n - 1
 * out = 2 * m
 * 从第 2 个等式出发，结合第 1 个等式：
 * in = m + n - 1 <= m + m - 1 = 2m - 1 = out - 1
 * 即可得 in + 1 <= out，也就是 in < out 恒成立。
 */
public class 验证二叉树的前序序列化 {

    public boolean isValidSerialization(String preorder) {
       String [] ss=preorder.split(",");
       int n=ss.length;
       int in =0,out=0;
        for (int i = 0; i <n ; i++) {
            if (!ss[i].equals("#")) out+=2;
            if (i !=0) in++;
            if (i !=n-1 && out <= in) return false;
        }
        return in == out;
    }
}
/**
 *时间复杂度：O(n)
 * 空间复杂度：O(n)
 */
